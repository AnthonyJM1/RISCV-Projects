
#C Program Model for read_string
// reads @a bytes from stdin into the string @a buf.
// Returns the number of bytes read
//int read_string(char *buf, int bytes);
//a0=buf, a1=bytes

.globl main 
.equ STDOUT, 1
.equ STDIN, 0
.equ __NR_READ, 63
.equ __NR_WRITE, 64
.equ __NR_EXIT, 93

.text
li ra,0xffffffff 

ebreak
main:
	# main() prolog
	addi sp, sp, -24
	sw ra, 20(sp)

	# main() body
	la a0, prompt
	call puts    

	mv a0, sp
	call gets

	mv a0, sp
	call puts

	# main() epilog
	lw ra, 20(sp)
	addi sp, sp, 24
	ret

.space 12288

sekret_fn:
	addi sp, sp, -4
	sw ra, 0(sp)
	la a0, sekret_data
	call puts
	lw ra, 0(sp)
	addi sp, sp, 4
	ret

puts:
    # Finding Length
    mv   t0, a0                # base
    mv   t1, a0                # scan
len_loop:
    lbu  t2, 0(t1)
    beq  t2, x0, len_done      # stop at NUL
    addi t1, t1, 1
    j    len_loop
len_done:
    sub  t3, t1, t0            # len = t1 - t0

    # write(s, len)
    li   a0, STDOUT
    mv   a1, t0
    mv   a2, t3
    li   a7, __NR_WRITE
    ecall
#Creating stack and writing out
    addi sp, sp, -16
    li   t2, 10                # '\n'
    sb   t2, 0(sp)
    li   a0, STDOUT
    addi a1, sp, 0
    li   a2, 1
    li   a7, __NR_WRITE
    ecall
    addi sp, sp, 16
    ret

    # a0 = pointer to buffer (from caller)
gets:
    mv   t0, a0          # save buffer pointer in t0
    li   a0, STDIN       # a0 = file descriptor 0 (stdin)
    mv   a1, t0          # a1 = where to store input
    li   a2, 100         # a2 = max bytes to read (dangerous if > buffer!)
    li   a7, __NR_READ   # system call: read
    ecall                # read(stdin, buf, 100)
    ret

.data
newline: .byte 10

.data
prompt:   .ascii  "Enter a message:\0 "
prompt_end:

.word 0
sekret_data:
.word 0x73564753, 0x67384762, 0x79393256, 0x3D514762, 0x0000000A
6, 0x3D514762, 0x0000000A
